<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>In.Confidence - Interactive Vinyl</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0a0a0a; color: white; font-family: sans-serif; }
        canvas { display: block; }
        .ui-overlay {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            pointer-events: none;
            text-align: center;
            width: 100%;
            z-index: 10;
        }
        .btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.8rem;
            display: inline-block;
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        .instruction {
            font-size: 0.75rem;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }
        #loading-screen {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        /* Hide file inputs */
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="text-center">
            <div id="spinner" class="inline-block w-8 h-8 border-4 border-white/20 border-t-white rounded-full animate-spin mb-4"></div>
            <div class="text-xs tracking-widest uppercase">Initializing...</div>
        </div>
    </div>

    <div class="ui-overlay">
        <div class="instruction">Click and drag to rotate â€¢ Scroll to zoom</div>
        
        <button class="btn" id="flip-btn">Flip Album</button>

        <div class="flex gap-2 mt-2">
            <label class="btn text-[10px] py-2 px-4 border-white/10">
                Upload Front
                <input type="file" id="upload-front" accept="image/*">
            </label>
            <label class="btn text-[10px] py-2 px-4 border-white/10">
                Upload Back
                <input type="file" id="upload-back" accept="image/*">
            </label>
        </div>

        <div class="mt-4">
            <h1 class="text-xl tracking-[0.3em] font-light">IN.CONFIDENCE</h1>
            <p class="text-[10px] opacity-40 tracking-widest mt-1">MONTY C. BENJAMIN</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, album;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let side = 1;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.6);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Try loading default textures, but proceed even if they fail
            const loader = new THREE.TextureLoader();
            let loadedCount = 0;
            let frontTex = null, backTex = null;

            const attemptCreate = () => {
                loadedCount++;
                if (loadedCount >= 2) {
                    createAlbum(frontTex, backTex);
                    hideLoading();
                }
            };

            // Attempt to load default files
            loader.load('IC_Vinyl_Front.jpg', 
                (tex) => { frontTex = tex; attemptCreate(); }, 
                undefined, 
                (err) => { console.log('Default front not found'); attemptCreate(); }
            );
            
            loader.load('IC_Vinyl_Back.jpg', 
                (tex) => { backTex = tex; attemptCreate(); }, 
                undefined, 
                (err) => { console.log('Default back not found'); attemptCreate(); }
            );
        }

        function hideLoading() {
            const screen = document.getElementById('loading-screen');
            screen.style.opacity = '0';
            setTimeout(() => screen.style.display = 'none', 500);
        }

        function createAlbum(frontTex, backTex) {
            const geometry = new THREE.BoxGeometry(3, 3, 0.08);
            
            const edgeMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 });
            
            const frontMaterial = frontTex ? 
                new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.4, metalness: 0.1 }) : 
                new THREE.MeshStandardMaterial({ color: 0x202020 });
            
            const backMaterial = backTex ? 
                new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.4, metalness: 0.1 }) : 
                new THREE.MeshStandardMaterial({ color: 0x151515 });

            // Ensure materials are assigned to correct faces
            // [Right, Left, Top, Bottom, Front, Back]
            const materials = [
                edgeMaterial, 
                edgeMaterial, 
                edgeMaterial, 
                edgeMaterial, 
                frontMaterial, 
                backMaterial
            ];

            album = new THREE.Mesh(geometry, materials);
            scene.add(album);

            setupEvents();
            setupUploads();
            animate();
        }

        function setupUploads() {
            const handleUpload = (e, materialIndex) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const loader = new THREE.TextureLoader();
                    loader.load(event.target.result, (tex) => {
                        if (album) {
                            album.material[materialIndex].map = tex;
                            album.material[materialIndex].needsUpdate = true;
                            
                            // Adjust roughness if switching from color to image
                            album.material[materialIndex].roughness = 0.4;
                            album.material[materialIndex].metalness = 0.1;
                            album.material[materialIndex].color.setHex(0xffffff);
                        }
                    });
                };
                reader.readAsDataURL(file);
            };

            // Material Index 4 is Front, 5 is Back
            document.getElementById('upload-front').addEventListener('change', (e) => handleUpload(e, 4));
            document.getElementById('upload-back').addEventListener('change', (e) => handleUpload(e, 5));
        }

        function setupEvents() {
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize);
            
            window.addEventListener('touchstart', (e) => onMouseDown(e.touches[0]), { passive: false });
            window.addEventListener('touchmove', (e) => onMouseMove(e.touches[0]), { passive: false });
            window.addEventListener('touchend', onMouseUp);

            document.getElementById('flip-btn').addEventListener('click', () => {
                side *= -1;
                targetRotation.y += Math.PI;
            });
        }

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (!isDragging) {
                if (album) {
                    const mouseX = (e.clientX / window.innerWidth) - 0.5;
                    const mouseY = (e.clientY / window.innerHeight) - 0.5;
                    album.rotation.x = currentRotation.x + (mouseY * 0.15);
                    album.rotation.y = currentRotation.y + (mouseX * 0.15);
                }
                return;
            }

            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };

            targetRotation.y += deltaMove.x * 0.01;
            targetRotation.x += deltaMove.y * 0.01;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() {
            isDragging = false;
            if (album) {
                currentRotation.x = targetRotation.x;
                currentRotation.y = targetRotation.y;
            }
        }

        function onWheel(e) {
            camera.position.z += e.deltaY * 0.005;
            camera.position.z = Math.max(3, Math.min(camera.position.z, 8));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (album) {
                album.rotation.y += (targetRotation.y - album.rotation.y) * 0.1;
                album.rotation.x += (targetRotation.x - album.rotation.x) * 0.1;
            }
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>